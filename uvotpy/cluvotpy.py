import os
import numpy as np
import scipy.integrate as integrate
from astropy.io import fits
from numpy.polynomial.polynomial import Polynomial
from iminuit import Minuit
from scipy.interpolate import CubicSpline
import warnings
import astropy.constants as cst
import astropy.units as u
from datetime import datetime, timezone
from typing import Union

warnings.filterwarnings('ignore')

# modify your CALDB dir here
CALDB = {'UVOTPY': f'{os.getenv("UVOTPY"):s}/calfiles',}

def resample(raw_edge, new_edge, raw_val, raw_err=None, raw_mask=None) -> tuple:
    """
    Resample raw_val from the old sample grid raw_edge to a new one new_edge.

    Paramters
    ---------
    raw_edge: numpy.ArrayLike
        The input/old sample grid of raw_val, len(raw_edge) == len(raw_val) + 1.

    new_edge: numpy.ArrayLike
        The output/new sample grid.

    raw_val: numpy.ArrayLike
        The input/old sampled value.

    raw_err: None | numpy.ArrayLike
        The uncertainty/error of the raw_val.

    raw_mask: None | numpy.ArrayLike
        The mask array of teh raw_val.

    Returns
    -------
    new_val, new_err, new_mask: tuple
        The resampled value, uncertainty/error, mask array.
        If raw_err (raw_mask) is None, new_err (new_mask) is None.
    """
    # par check
    if len(raw_edge) != len(raw_val) + 1:
        raise ValueError('Error 1')
    if (raw_err is not None) and (len(raw_err) != (len(raw_val))):
        raise ValueError('Error 2')
    if (raw_mask is not None) and (len(raw_mask) != (len(raw_val))):
        raise ValueError('Error 3')
    # done

    cut_01 = lambda x: np.minimum(np.maximum(x, 0.), 1.)

    raw_bin = raw_edge[1:] - raw_edge[:-1]
    new_bin = new_edge[1:] - new_edge[:-1]
    # get pix weigth map
    raw_edge_2d = np.repeat([raw_edge], len(new_edge), axis=0)
    new_edge_2d = np.repeat([new_edge], len(raw_edge), axis=0).T
    raw_bin_2d = np.repeat([raw_bin], len(new_edge)-1, axis=0)
    wei_lo = cut_01(-(new_edge_2d[:-1, :-1] - raw_edge_2d[1:, 1:]) / raw_bin_2d)
    wei_hi = cut_01((new_edge_2d[1:, 1:] - raw_edge_2d[:-1, :-1]) / raw_bin_2d)
    wei_map = wei_lo + wei_hi - 1

    new_val = (wei_map @ (raw_val*raw_bin)) / new_bin
    new_err = None if raw_err is None else np.sqrt(wei_map @ (raw_err*raw_bin)**2) / new_bin
    new_mask = None if raw_mask is None else (wei_map @ raw_mask).astype(bool)
    
    return new_val, new_err, new_mask

def bin_contineous_func(func, bin_edge):
    bin_val = [integrate.quad(func, lo_, hi_) for lo_, hi_ in zip(bin_edge[:-1], bin_edge[1:])]
    bin_val = np.array(bin_val, dtype=float)
    return bin_val

class CleanExtractor:
    """
    The extractor to remove the second order ontamination from Swift/UVOT UV nominal spectra.

    Parameters
    ----------
        pha: str | PathLike
            The first order PHA file generated by the uvotpy package.

    Examples
    --------
        .print_par() prints key parameters on your terminal. Please pay attention to the
        "Distance of 1st anchor from the ref position", if the value is greater than 150,
        the cleaned spectrum could be unreliable.

        .extract_cl_spec() runs the script to extract the cleaned spectrum.

        .write_cl_spec() writes the cleaned spectrum to the same folder of the input xxx.pha
        as xxx_cl.pha

        .plot_spec() plots the 2d, raw and cleaned spectra, it can be saved if you want.
        The only input parameter is EDGEs of the wave length bin.

        >>> import matplotlib.pyplot as plt
        >>> cl_extractor = CleanExtractor('example/sw00554620000ugu_1ord_1_f.pha')
        >>> cl_extractor.print_par()
        >>> cl_extractor.extract_cl_spec()
        >>> cl_extractor.write_cl_spec()
        >>> cl_extractor.plot_spec(np.linspace(1700, 5000, 133))
        >>> # plt.savefig('cl_spec.png', bbox_inches='tight')
        >>> plt.show()
    """
    ank_cen = np.array([988.4, 1080.2])
    caldb = CALDB['UVOTPY']
    # plz do not change names of files/extensions below.
    ord2_arf = {
        '160': (
            'swugu0160_ax1080ay1000_dx100dy100_o2_20041120v001.arf',
            'SPECRESP0160GRISM2NDORDER'
        ),
        '200': (
            # 'swugu0200_ax1080ay1000_dx100dy100_o2_20041120v001.arf',
            'swugu0200_ax1080ay1000_dx100dy100_o2_20041120v001_cl.arf',
            'SPECRESP0200GRISM2NDORDER'
        ),
        '955': (
            'swugv0955_ax1080ay1000_dx100dy100_o2_20041120v001.arf',
            'SPECRESP0955GRISM2NDORDER'
        ),
        '1000': ('None', 'None')
    }

    def __init__(self, pha: Union[str, os.PathLike], fit_wl: bool = True, interpolate_arf: bool = True):
        self.__pha = pha
        self.__par = None
        self.__wl = None
        self.__flux = None

        self.spec2d = None
        self.spec1d = None
        self.__good_par = None
        self.__par_initialiation()
        
        self.__wl_calibration(fit=fit_wl)
        self.__flux_calibration(interpolate=interpolate_arf)
    
    @staticmethod
    def __get_hist(hist, match_str, replace_str=None) -> str:
        hist_line = list(filter(lambda x: match_str in x, hist))[0]
        out_str = hist_line.replace(match_str, '')
        
        if replace_str is None: return out_str

        for ele_ in replace_str:
            out_str = out_str.replace(ele_[0], ele_[1])
        return out_str

    def __par_initialiation(self):
        with fits.open(self.__pha, memmap=False) as hdul_:
            self.spec2d = hdul_['SPECTRUM_IMAGE'].data
            hdr = hdul_['SPECTRUM'].header
            calspec = hdul_['CALSPEC'].data
            spectrum = hdul_['SPECTRUM'].data
        

        # read parameters
        hist = hdr['HISTORY']
        self.__hist = hist
        self.__par = {
            'pha': self.__pha,
            'grism': hdr['filter'],
            'metStart': str(hdr['TSTART']),
            'metStop': str(hdr['TSTOP']),
            'whlPos': hdr['DETNAM'].replace(' ', ''),
            'ankDt': self.__get_hist(hist, 'anchor1=', [(' ', ''), (',', ', ')]),
            'apWid': self.__get_hist(hist, 'TRACKWID= '),
            'o1Arf': self.__get_hist(hist, 'Flux calibration file: '),
        }
        ank_dis = np.sum((np.array(eval(self.__par['ankDt'])) - self.ank_cen)**2)**0.5
        self.__par['ankDis'] = f'{ank_dis:.2f}'
        self.__par['o1Arf'] += '+' + self.__get_hist(
            hist, 'Selected nearest effective area FITS extension '
        )
        if '_O1' not in self.__par['o1Arf']:
            nextID = [
                i_
                for i_ in range(len(hist))
                if 'Selected nearest effective area FITS extension ' in hist[i_]
            ][0] + 1
            self.__par['o1Arf'] += hist[nextID]
        self.__par['o2Arf'] = 'None' \
            if self.__par['whlPos'] is None else \
            '+'.join(self.ord2_arf[self.__par['whlPos']])

        self.__good_par = self.check_par()
        if not self.__good_par: return
        
        # spec1d init
        o1Sel = (~np.isnan(calspec['FLUX'])) & (calspec['FLUX'] != 0)
        o2Sel = (~np.isnan(calspec['FLUX2'])) & (calspec['FLUX2'] != 0)
        o2Sel = o2Sel & (calspec['PIXNO2'] <= calspec['PIXNO'][o1Sel][-1])
        self.spec1d = {
            1: {
                'sel': o1Sel,
                'pixNo': calspec['PIXNO'][o1Sel],
                'lam': calspec['LAMBDA'][o1Sel],
                'flux': calspec['FLUX'][o1Sel],
                'fluxErr': calspec['FLUXERR'][o1Sel],
                'rwRate': calspec['NETRATE'][o1Sel]\
                    * calspec['SP1_COIF'][o1Sel]\
                    * calspec['APERCOR1'][o1Sel],
            },
            2: {
                'sel': o2Sel,
                'pixNo': calspec['PIXNO2'][o2Sel],
                'lam': calspec['LAMBDA2'][o2Sel]
            },
            'xspec': {
                'rate': spectrum['RATE'] # the direction of the wavelength is from long to short!
            }
        }

        # wl cal init
        self.pn_edge = {
            1: np.append(self.spec1d[1]['pixNo'] - 0.5, self.spec1d[1]['pixNo'][-1] + 0.5),
            2: np.append(self.spec1d[2]['pixNo'] - 0.5, self.spec1d[2]['pixNo'][-1] + 0.5),
        }
        self.__wl = {
            'fitted': False,
            'dist12': float(self.__get_hist(hist, 'DIST12= ')),
            'poly': {
                1: {
                    'a0': float(self.__get_hist(hist, 'DISP1_4= ')),
                    'a1': float(self.__get_hist(hist, 'DISP1_3= ')),
                    'a2': float(self.__get_hist(hist, 'DISP1_2= ')),
                    'a3': float(self.__get_hist(hist, 'DISP1_1= ')),
                    'a4': float(self.__get_hist(hist, 'DISP1_0= ')),
                },
                2: {
                    'a0': float(self.__get_hist(hist, 'DISP2_2= ')),
                    'a1': float(self.__get_hist(hist, 'DISP2_1= ')),
                    'a2': float(self.__get_hist(hist, 'DISP2_0= '))
                }
            }
        }

        # flux cal init
        rwO1Rate = np.full_like(o1Sel, fill_value=np.nan, dtype=float)
        rwO1Rate[o1Sel] = self.spec1d[1]['rwRate']
        xsO1Rate = self.spec1d['xspec']['rate'][::-1]
        sens_ = xsO1Rate / rwO1Rate
        sens = np.ma.mean(np.ma.array(sens_, mask=np.isnan(sens_)))
        self.__flux = {'sens': sens}
        self.spec1d[1]['rwRate'] *= sens

    def __wl_calibration(self, fit=True):
        if not self.__good_par: return
        need_fit = fit
        fitted = self.__wl['fitted']
        dist12 = self.__wl['dist12']
        polyPar = self.__wl['poly']

        if need_fit and not fitted:
            def __fit_poly(ls_func, **kwargs) -> dict:
                """
                Parameters
                ----------
                    ls_func : callable
                    **kwargs : parameters parsed to ls_func
                
                Return
                ------
                    fitted parameters of ls_func : dict
                        the format is same as the kwargs
                """
                fitter = Minuit(ls_func, **kwargs)
                for par_ in kwargs:
                    parRange = (0.8 * kwargs[par_], 1.2 * kwargs[par_])\
                        if kwargs[par_] > 0 else\
                        (1.2 * kwargs[par_], 0.8 * kwargs[par_])
                    fitter.limits[par_] = parRange
                fitter.errordef = 1
                fitter.migrad()
                return {par_: fitter.values[par_] for par_ in fitter.parameters}
            def ord1_ls(a0, a1, a2, a3, a4):
                pn = self.spec1d[1]['pixNo']
                lam = self.spec1d[1]['lam']
                y = Polynomial((a0, a1, a2, a3, a4))(pn)
                return np.sum((lam - y)**2)
            def ord2_ls(a0, a1, a2):
                pn = self.spec1d[2]['pixNo']
                lam = self.spec1d[2]['lam']
                y = Polynomial((a0, a1, a2))(pn - dist12)
                return np.sum((lam - y)**2)
            self.__wl['fitted'] = True
            self.__wl['poly'][1] = __fit_poly(ord1_ls, **polyPar[1])
            self.__wl['poly'][2] = __fit_poly(ord2_ls, **polyPar[2])

        def __pn2lam(order: int = 1) -> np.ndarray:
            polyCof = tuple(self.__wl['poly'][order].values())
            pnEdge = self.pn_edge[order]
            func = Polynomial(polyCof)
            def wrapper(pixNo):
                pixNo = np.array([pixNo], dtype=float).flatten()
                outArr = np.full_like(pixNo, fill_value=np.nan, dtype=float)
                goodSel = (pixNo >= pnEdge[0]) & (pixNo <= pnEdge[-1])
                if order == 1:
                    shiftVal = 0.
                elif order == 2:
                    shiftVal = -dist12
                else:
                    print('Wrong order number, must be 1 or 2.')
                    exit()
                x = pixNo + shiftVal
                outArr[goodSel] = func(x[goodSel])
                return outArr
            return wrapper
        self.pn2lam = {1: __pn2lam(1), 2: __pn2lam(2)}
        self.lam_edge = {1: self.pn2lam[1](self.pn_edge[1]), 2: self.pn2lam[2](self.pn_edge[2])}
        self.lamWid = {
            1: self.lam_edge[1][1:] - self.lam_edge[1][:-1],
            2: self.lam_edge[2][1:] - self.lam_edge[2][:-1],
        }

        def __lam2pn(order: int = 1) -> np.ndarray:
            samplePix = self.pn_edge[order]
            sampleLam = self.lam_edge[order]
            func = CubicSpline(sampleLam, samplePix)
            def __wrapper(lam):
                lam = np.array([lam], dtype=float).flatten()
                outArr = outArr = np.full_like(lam, fill_value=np.nan, dtype=float)
                goodSel = (lam >= sampleLam[0]) & (lam <= sampleLam[-1])
                outArr[goodSel] = func(lam[goodSel])
                return outArr
            return __wrapper
        self.lam2pn = {1: __lam2pn(1), 2: __lam2pn(2)}

    def __get_bin_arf(self, order: int = 1, interpolate: bool = True):
        if not self.__good_par: return
        if order not in (1, 2):
            raise ValueError('Wrong order number!')
        
        arf = self.__par[f'o{order:d}Arf']
        lam = self.spec1d[order]['lam']
        if arf is None:
            return np.full_like(lam, fill_value=np.nan, dtype=float)
        
        arfFile, arfExt = arf.split('+')
        arfFile = os.path.join(self.caldb, arfFile)
        arfData = fits.getdata(arfFile, extname=arfExt, memmap=False)

        wlEdge = np.append(arfData['WAVE_MIN'][::-1], arfData['WAVE_MAX'][0])
        resp = arfData['SPECRESP'][::-1]

        if interpolate:
            wlMid = (wlEdge[:-1] + wlEdge[1:]) / 2
            cs = CubicSpline(wlMid, resp, extrapolate=True)
            def arf_func(x):
                out_arr = np.full_like(x, fill_value=np.nan, dtype=float)
                sel = (x >= wlEdge[0]) & (x <= wlEdge[-1])
                out_arr[sel] = cs(x[sel])
                return out_arr
            new_resp = arf_func(lam)
        else:
            lamEdge = self.lam_edge[order]
            new_resp = resample(wlEdge, lamEdge, resp)[0]

        return new_resp

    def __erg_per_bin(self, order: int = 1):
        lam = self.spec1d[order]['lam']
        energy = cst.h * cst.c / lam / u.AA
        return energy.to(u.erg).value

    def __flux_calibration(self, interpolate: bool = True):
        if not self.__good_par: return
        cr2flux = {1: self.spec1d[1]['flux'] / self.spec1d[1]['rwRate']}
        ergPerBin = {
            1: self.__erg_per_bin(1),
            2: self.__erg_per_bin(2),
        }
        o1BinArf = ergPerBin[1] / self.lamWid[1] / cr2flux[1]
        self.__flux['arf'] = {
            # 1: self.__get_bin_arf(1, interpolate),
            1: o1BinArf,
            2: self.__get_bin_arf(2, interpolate),
        }
        self.__flux['cr2flux'] = {
            1: ergPerBin[1] / self.__flux['arf'][1] / self.lamWid[1],
            # 1: cr2flux[1],
            2: ergPerBin[2] / self.__flux['arf'][2] / self.lamWid[2],
        }

        return
    
    def extract_cl_spec(self):
        if not self.__good_par: return

        cr2flux = self.__flux['cr2flux']
        totRate = self.spec1d[1]['rwRate']
        refFlux = self.spec1d[1]['flux']
        refFluxErr = self.spec1d[1]['fluxErr']
        totRateErr = refFluxErr / refFlux * totRate

        estO2Flux, estO2FluxErr, _ = resample(
            self.lam_edge[1], self.lam_edge[2],
            refFlux, refFluxErr
        )
        estO2Cr = estO2Flux / cr2flux[2]
        estO2CrErr = estO2FluxErr / cr2flux[2]
        clO1Cr = totRate[:]
        clO1CrErr = np.zeros_like(clO1Cr)
        dpix12 = self.spec1d[2]['pixNo'][0] - self.spec1d[1]['pixNo'][0]
        o2Len = len(self.spec1d[2]['pixNo'])
        clO1Cr[dpix12:dpix12+o2Len] -= estO2Cr
        clO1CrErr[dpix12:dpix12+o2Len] = estO2CrErr
        clO1CrErr = np.sqrt(clO1CrErr**2 + totRateErr**2)

        o1Sel = self.spec1d[1]['sel']
        self.spec1d[1]['clRate'] = np.full_like(o1Sel, fill_value=np.nan, dtype=float)
        self.spec1d[1]['clRate'][o1Sel] = clO1Cr
        self.spec1d[1]['clFlux'] = clO1Cr * cr2flux[1]
        self.spec1d[1]['clFluxErr'] = clO1CrErr * cr2flux[1]

        return 

    def write_cl_spec(self):
        if not self.__good_par: return
        rwPha = self.__pha
        clPha = rwPha.replace('.pha', '_cl.pha')

        rwHdul = fits.open(rwPha, memmap=False)
        clHdul = fits.HDUList([rwHdul['PRIMARY']])
        clHdul['PRIMARY'].header.set(
            'EXTNAME', value='PRIMARY', comment='name of this extension', after='EXTEND'
        )
        
        lamEdge = self.lam_edge[1]
        o1Sel = self.spec1d[1]['sel']
        chan = np.arange(1, len(lamEdge), dtype=int)
        chanLen = len(chan)
        rate = self.spec1d[1]['clRate'][o1Sel][::-1]
        rateErr = rwHdul['SPECTRUM'].data['STAT_ERR'][o1Sel[::-1]]
        qual = np.ones_like(chan, dtype=int)
        qual[(lamEdge[:-1] >= 1700.) & (lamEdge[1:] <= 5000.)] = 0
        arrDict = {
            'CHANNEL': chan,
            'RATE': rate,
            'STAT_ERR': rateErr,
            'QUALITY': qual[::-1],
            'GROUPING': [1] * chanLen,
        }
        specCols = fits.ColDefs([])
        for col_ in rwHdul['SPECTRUM'].data.columns:
            specCols.add_col(
                fits.Column(
                    name=col_.name, format=col_.format, unit=col_.unit,
                    array=arrDict[col_.name]
                )
            )
        specCols.add_col(
            fits.Column(name='GROUPING', format='I', unit='', array=arrDict['GROUPING'])
        )
        specHdu = fits.BinTableHDU.from_columns(specCols, header=rwHdul['SPECTRUM'].header)
        clHdul.append(specHdu)

        calCols = fits.ColDefs([])
        for col_ in rwHdul['CALSPEC'].data.columns:
            calCols.add_col(
                fits.Column(
                    name=col_.name, format=col_.format, unit=col_.unit,
                    array=rwHdul['CALSPEC'].data[col_.name][o1Sel]
                )
            )
        calCols.add_col(
            fits.Column(
                name='CL_FLUX', format='D', unit='erg cm-2 s-1 A-1',
                array=self.spec1d[1]['clFlux']
            )
        )
        calCols.add_col(
            fits.Column(
                name='CL_FLUX_ERR', format='D', unit='erg cm-2 s-1 A-1',
                array=self.spec1d[1]['clFluxErr']
            )
        )
        calCols.add_col(
            fits.Column(
                name='CL_QUAL', format='I', unit='',
                array=qual
            )
        )
        calHdu = fits.BinTableHDU.from_columns(calCols, header=rwHdul['CALSPEC'].header)
        clHdul.append(calHdu)
        clHdul.append(rwHdul['SPECTRUM_IMAGE'])

        clHdul['SPECTRUM'].header['CRPIX1'] = f'(1,{chanLen:d})'
        clHdul['SPECTRUM'].header['TLMAX1'] = chanLen
        clHdul['SPECTRUM'].header['DETCHANS'] = chanLen
        clHdul['SPECTRUM'].header['POISSERR'] = False
        clHdul['SPECTRUM'].header['CHANTYPE'] = 'PI'

        utc = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S')
        clHdul['PRIMARY'].header['DATE'] = utc
        clHdul['SPECTRUM'].header['DATE'] = utc
        clHdul['CALSPEC'].header['DATE'] = utc
        clHdul['SPECTRUM_IMAGE'].header['DATE'] = utc
        clHdul.writeto(clPha, overwrite=True)
        rwHdul.close()
        
        return

    def print_par(self):
        if not self.__good_par: return
        
        rep_dict = {
            'pha': 'PHA file: ',
            'grism': 'Grism: ',
            'metStart': 'MET start: ',
            'metStop': 'MET stop: ',
            'whlPos': 'Wheel position: ',
            'ankDt': '1st anchor [dt pix]: ',
            'ankDis': 'Distance of 1st anchor from the ref position: ',
            'apWid': 'Track width: ',
            'o1Arf': '1st order effective area file: ',
            'o2Arf': '2nd order effective area file: ',
        }
        out_list = [rep_dict[key_] + self.__par[key_] for key_ in rep_dict if key_ in self.__par]
        out_str = '\n'.join(out_list)
        print(out_str)

    def check_par(self) -> bool:
        if self.__par['grism'] != 'UGRISM':
            print('The grism is not UGRISM, no cleaned 1st-order spectrum can be extracted.')
            return False
        if self.__par['whlPos'] != '200':
            print('The wheel position is not 200, no cleaned 1st-order spectrum can be extracted.')
            return False

        ankDis = float(self.__par['ankDis'])
        if ankDis > 150.:
            ans = input(f'Warning: The distance between the anchor position and the reference position is {ankDis:.2f}>150, which may lead to unreliable results. Extract the cleaned spectrum anyway (y/n)? [n]: ').strip()
            if not ans: return False
            if 'n' in ans.lower(): return False
            if 'y' not in ans.lower(): return False
            if 'y' in ans.lower(): True

        return True

if __name__ == '__main__':
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    cl_extractor = CleanExtractor('example/sw00554620000ugu_1ord_1_f.pha')
    cl_extractor.print_par()
    cl_extractor.extract_cl_spec()
    cl_extractor.write_cl_spec()
    exit()